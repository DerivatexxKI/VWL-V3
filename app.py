import streamlit as st
import openai
import os
from docx import Document
from docx.shared import Inches, Pt
from io import BytesIO
from datetime import datetime
import pdfplumber
import tiktoken  # NEU: f√ºr Tokenz√§hlung

# API-Key setzen
openai.api_key = os.getenv("OPENAI_API_KEY")

st.set_page_config(page_title="Volkswirtschaftliche Prognose", page_icon="üìà")
st.title("üìà Volkswirtschaftliche Prognose f√ºr Regionalbanken")

# Uploadfeld f√ºr PDF- oder Word-Dateien
uploaded_files = st.file_uploader(
    "üìé Relevante PDF- oder Word-Dokumente hochladen (optional)",
    type=["pdf", "docx"],
    accept_multiple_files=True
)

# Inhalte aus hochgeladenen Dateien extrahieren
extracted_texts = []
MAX_PAGES = 25  # Maximal 25 Seiten pro PDF auslesen
if uploaded_files:
    for file in uploaded_files:
        try:
            if file.name.endswith(".pdf"):
                with pdfplumber.open(file) as pdf:
                    text = "\n".join(page.extract_text() or "" for page in pdf.pages[:MAX_PAGES])
                    if not text.strip():
                        st.warning(f"‚ö†Ô∏è Keine lesbaren Textinhalte in PDF '{file.name}' erkannt.")
                        continue
                    extracted_texts.append(text)
                    if len(text.strip()) < 500:
                        st.warning(f"‚ö†Ô∏è Wenig Text erkannt in PDF '{file.name}'. Die Datei enth√§lt m√∂glicherweise eingescannten oder nicht maschinenlesbaren Text.")
            elif file.name.endswith(".docx"):
                from docx import Document as DocxDocument
                docx = DocxDocument(file)
                text = "\n".join([para.text for para in docx.paragraphs])
                if not text.strip():
                    st.warning(f"‚ö†Ô∏è Keine lesbaren Textinhalte in Word-Datei '{file.name}' erkannt.")
                    continue
                extracted_texts.append(text)
                if len(text.strip()) < 500:
                    st.warning(f"‚ö†Ô∏è Wenig Text erkannt in Word-Datei '{file.name}'. Bitte pr√ºfen, ob sie inhaltlich korrekt gef√ºllt ist.")
        except Exception as e:
            st.error(f"‚ùå Fehler beim Verarbeiten der Datei '{file.name}': {e}")

# Tokenz√§hler definieren
encoding = tiktoken.encoding_for_model("gpt-4")
def num_tokens_from_string(string: str) -> int:
    return len(encoding.encode(string))

# Button zur Prognoseerstellung
if st.button("üìà Prognose jetzt generieren und als Word-Datei exportieren"):
    context_text = "\n\n".join(extracted_texts)

    # Begrenzung der Token-Menge auf 8000 (‚âà Sicherheitspuffer)
    max_tokens = 8000
    tokens = num_tokens_from_string(context_text)
    if tokens > max_tokens:
        st.warning(f"‚úÇÔ∏è Der hochgeladene Text wurde auf {max_tokens} Tokens gek√ºrzt (urspr√ºnglich: {tokens}).")
        while num_tokens_from_string(context_text) > max_tokens:
            context_text = context_text[:-1000]  # iterativ k√ºrzen
    st.info(f"üìè Eingabeumfang: {num_tokens_from_string(context_text):,} Tokens")

    prompt = f"""
    Du bekommst folgende kontextuelle Dokumente als Grundlage f√ºr eine Prognose:

    {context_text}

    Erstelle darauf basierend eine volkswirtschaftliche Prognose f√ºr die Mittelfristplanung einer kleinen deutschen Regionalbank mit folgenden Bestandteilen:

    1. Erstelle eine Tabelle mit Planungspr√§missen zu folgenden Punkten:
       - BIP-Wachstum
       - Inflation (HVPI)
       - Leitzinsen (EZB)
       - Arbeitslosenquote
       - EUR/USD Wechselkurs
       - Energiepreise (Brent, Gas)

    2. Gib f√ºr jeden dieser makro√∂konomischen Cluster eine **ausf√ºhrlich begr√ºndete, analytisch tiefgehende** Prognose f√ºr die n√§chsten 3‚Äì5 Jahre ab:
       - Bruttoinlandsprodukt (BIP): Entwicklung, Sektoren, Prognoserisiken, Einflussgr√∂√üen
       - Inflation (HVPI): Kerninflation vs. Gesamt, Preisentwicklungen, Energie, L√∂hne
       - Arbeitsmarkt: Besch√§ftigungstrends, Fachkr√§ftemangel, Sektoren
       - Geldpolitik der EZB: Begr√ºndung der Zinspolitik, Ausblick
       - Zinsstruktur (Swapkurve): Verlauf, Markterwartung, Einflussfaktoren
       - Geopolitische Risiken: Regionen, Auswirkungen, Szenarien
       - Auswirkungen auf das Bankgesch√§ft: Zins√ºberschuss, Kreditnachfrage, Risiken
       - Wirtschaftliche Risiken: interne/externe Unsicherheiten, Stressszenarien

    F√ºr jeden dieser Abschnitte:
    - Beginne mit einer kurzen pr√§gnanten **Zusammenfassung** (3‚Äì4 S√§tze)
    - Erstelle im Anschluss einen **detaillierten Hauptteil** mit mindestens 1800 Zeichen pro Abschnitt
    - Nutze klare Zwischen√ºberschriften, Aufz√§hlungen, ggf. tabellarische Vergleiche
    - F√ºhre Analysen, Begr√ºndungen und Beispiele an

    Verwende bevorzugt die Informationen aus den bereitgestellten Dokumenten. Wenn zu einem Bereich keine konkreten Aussagen enthalten sind, erg√§nze diesen Abschnitt durch fundierte eigene Einsch√§tzungen. Zitiere bei konkreten Aussagen aus dem Upload den Wortlaut sinngem√§√ü.

    Verwende professionelle, sachliche Sprache. Die Inhalte sollen geeignet f√ºr ein Vorstandsgremium sein.
    """

    with st.spinner("Generiere Prognose..."):
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.7,
                max_tokens=3000,
            )
            result = response["choices"][0]["message"]["content"]
            st.success("Prognose erfolgreich erstellt!")
            st.markdown(result)

            # Word-Dokument erstellen
            doc = Document()

            # Titelblatt
            doc.add_heading("Volkswirtschaftliche Mittelfristprognose", 0)
            doc.add_paragraph("Erstellt am: " + datetime.now().strftime("%d.%m.%Y"))
            doc.add_paragraph("Zielgruppe: Vorstand und Planungsteam der Regionalbank")
            doc.add_page_break()

            # Inhaltsverzeichnis-Hinweis
            doc.add_paragraph("Inhaltsverzeichnis wird automatisch generiert (in Word aktivieren).")
            doc.add_page_break()

            # Inhalt einf√ºgen (abschnittsweise)
            for section in result.split("\n\n"):
                doc.add_paragraph(section, style='Normal')

            # Formatierung optimieren
            style = doc.styles['Normal']
            font = style.font
            font.name = 'Calibri'
            font.size = Pt(11)

            # Download-Link erzeugen
            buffer = BytesIO()
            doc.save(buffer)
            buffer.seek(0)

            st.download_button(
                label="üìÑ Word-Bericht herunterladen",
                data=buffer,
                file_name="vwl_prognose.docx",
                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            )

        except Exception as e:
            st.error(f"Fehler beim Abruf der Prognose: {e}")
